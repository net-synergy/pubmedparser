<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-04-21 Thu 23:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pubmed parser</title>
<meta name="author" content="David R. Connell" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>

<style>
  pre.src {
    background-color: #FAFAFA;
  }

  div, p {
    margin: auto;
    max-width: 48em;
    line-height: 1.4;
  }

  p {
    font-size 11pt;
    font-weight: normal;
    color: #222222;
    text-indent: 4ex;
  }

  /* Treat underline as bold italic. Bit of a hack, bold and
  italicized is being ignored by pandoc when exporting to docx so
  using underline to identify text to manually change style to
  emphasize in word. But the intended effect is actually italic and
  bold so using this. */
  b, span.underline {
    font-family: sans-serif;
    font-weight: bold;
    font-style: italic;
    color: black;
    text-decoration: none;
  }

  code {
    color: black;
    font-weight: 600;
  }

  h1, h2, h3, h4, h5, h6 {
    color: black;
    font-family: sans-serif;
    margin-bottom: 0.5ex;
    margin-top: 3ex;
  }

  h2 {
    font-size: 24pt;
  }

  h3 {
    font-size: 14pt;
  }

  a:link {
    color: #0031a9;
  }

  a:visited {
    color: #673AB7;
  }

  pre.src:before {
    font-family: sans-serif;
    font-weight: bold;
    font-size: 12;
  }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Pubmed parser</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#structure-file">1. Structure file</a></li>
<li><a href="#example-creating-node-and-edges">2. Example: creating node and edge files for importing with neo4j</a>
<ul>
<li><a href="#org4b301de">2.1. Generating node files</a></li>
<li><a href="#orgb1db7a1">2.2. Generating edge files</a></li>
<li><a href="#orgdd78b6b">2.3. Joining key's features to key</a></li>
<li><a href="#orga19c765">2.4. Cleaning up (replacing temporary separators)</a></li>
<li><a href="#orgac9c7f8">2.5. Adding headers</a></li>
</ul>
</li>
<li><a href="#example-overlap">3. <span class="todo TODO">TODO</span> Example: calculating overlap</a></li>
<li><a href="#orgfcedd02">4. Example: importing with neo4j</a></li>
</ul>
</div>
</div>
<p>
Read XML files and pull out selected values.
Values to collect are determined by paths found in a <a href="#structure-file">structure file</a>.
The structure file also includes a key which associates the values with a parent element and names, which determine which file to place the elements in.
</p>

<p>
Files can be passed as either gzipped or uncompressed XML files or from standard in.
</p>

<p>
For more info on Pubmed's XML files see: <a href="https://dtd.nlm.nih.gov/ncbi/pubmed/doc/out/190101/index.html">pubmed_190101.dtd.</a>
</p>

<p>
Usage:
</p>
<div class="org-src-container">
<pre class="src src-sh">xml_read --cache-dir=cache --structure-file=structure.yml <span style="color: #FFAB91;">\</span>
    data/*.xml.gz
</pre>
</div>

<p>
The cache directory is where the results are stored.
</p>

<p>
Build:
Requires <code>zlib</code>
</p>
<div class="org-src-container">
<pre class="src src-sh">make all
</pre>
</div>

<div id="outline-container-structure-file" class="outline-2">
<h2 id="structure-file"><span class="section-number-2">1.</span> Structure file</h2>
<div class="outline-text-2" id="text-structure-file">
<p>
The structure file is a YAML file containing key-value pairs for different tags and paths.
There are four required keys: <code>root</code>, <code>key</code>, <code>key_features</code>, and <code>nodes</code>.
<code>Root</code> provide the top-level tag, in the case of the pubmed files this will be <code>PubmedArticleSet</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh">root: <span style="color: #FFAB91;">"PubmedArticleSet"</span>
</pre>
</div>

<p>
Only tags below the root tag will be considered.
</p>

<p>
<code>Key</code> is a reference tag.
In the pubmed case all data is with respect to a publication, so the key should identify the publication the values are linked to.
The <code>PMID</code> tag is a suitable candidate.
</p>

<div class="org-src-container">
<pre class="src src-sh">key: <span style="color: #000000;">{</span>
  Publication: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/PMID"</span>
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
Unlike <code>root</code>, the value of <code>key</code> should be a map.
In the example above, <code>key</code> is named publication and it's value is an XML path.
The name is used to determine the file to write <code>PMID</code> values to.
This file acts as a reference for all publications seen, even those for which no other value was found.
Key's value is a path indicating where to find the desired tag in the XML hierarchy.
All paths start after the root.
</p>

<p>
Both <code>key_features</code> and <code>nodes</code> determine the other values to collect.
The <code>read_xml</code> program does not distinguish between them, but it is useful for post-processing the data if we keep them separate (see <a href="#example-creating-node-and-edges">2</a>).
<code>Key_features</code> is for values that are apart of the key's node.
For instance, the date of publication is specific to the publication, all publications have one, and only one, publication date.
<code>Nodes</code> handles other values that characterize a publication but are can have any number (including 0) of instances, such as references and authors.
These make up distinct node type (i.e. a given author is a node of type author which can be connected to various other nodes such as the publications that author contributed to).
</p>

<div class="org-src-container">
<pre class="src src-sh">key_features: <span style="color: #000000;">{</span>
  Year: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/Article/Journal/JournalIssue/PubDate/Year"</span>,
  Language: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/Article/Language"</span>
<span style="color: #000000;">}</span>

nodes: <span style="color: #000000;">{</span>
  Author: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/Article/AuthorList/Author/{LastName,ForeName}"</span>,
  Grant: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/Article/GrantList/Grant/GrantID"</span>,
  Chemical: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/ChemicalList/Chemical/NameOfSubstance/@UI"</span>,
  Qualifier: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/MeshHeadingList/MeshHeading/QualifierName/@UI"</span>,
  Descriptor: <span style="color: #FFAB91;">"/PubmedArticle/MedlineCitation/MeshHeadingList/MeshHeading/DescriptorName/@UI"</span>,
  Reference: <span style="color: #FFAB91;">"/PubmedArticle/PubmedData/ReferenceList/Reference/ArticleIdList/ArticleId/[@IdType='pubmed']"</span>
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
In the above example there is some special syntax.
For <code>author</code> multiple values are returned each time the <code>author</code> tag is found.
This is expressed by using the <code>{child_tag1,child_tag2,...}</code> notation.
Each child tag under the parent tag is collected and returned in a single row, represented multiple node features.
This notation prevents mismatches between features of a given node if any tags are missing.
In the case a tag is missing an empty string is printed.
</p>

<p>
To get an attribute from a tag, the <code>@attribute</code> notation is used&#x2014;as in the <code>chemical</code> node.
Whenever a path ends with an attribute <code>xml_read</code> will collect both the attribute and tag value.
</p>

<p>
Lastly, <code>[@attribute='value']</code> filters for attributes with the supplied values.
In the case of <code>reference</code> above this will ensure all references are identified by <code>PMID</code> as opposed to other IDs, such as DOI, so <code>references</code> can be linked with <code>publication</code> nodes.
</p>

<p>
This example structure file can be found in the example directory of this project at: <a href="./example/structure.yml">./example/structure.yml</a>
</p>
</div>
</div>

<div id="outline-container-example-creating-node-and-edges" class="outline-2">
<h2 id="example-creating-node-and-edges"><span class="section-number-2">2.</span> Example: creating node and edge files for importing with neo4j</h2>
<div class="outline-text-2" id="text-example-creating-node-and-edges">
<p>
The resulting values can be used to generate node and edge files that work with <code>neo4j</code>.
First step is to set up the environment:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">top_dir</span>=../$<span style="color: #000000;">(</span>dirname $<span style="color: #37474F; font-weight: bold;">0</span><span style="color: #000000;">)</span>
<span style="color: #37474F; font-weight: bold;">bin_dir</span>=$<span style="color: #37474F; font-weight: bold;">top_dir</span>/bin
<span style="color: #37474F; font-weight: bold;">cache_dir</span>=~/Documents/david/data/synergy/cache
<span style="color: #37474F; font-weight: bold;">data_dir</span>=~/Documents/david/data/pubmed
<span style="color: #37474F; font-weight: bold;">structure_file</span>=$<span style="color: #37474F; font-weight: bold;">top_dir</span>/example/structure.yml
<span style="color: #37474F; font-weight: bold;">import_dir</span>=~/Documents/david/data/synergy/import
<span style="color: #37474F; font-weight: bold;">delete_cache</span>=false <span style="color: #B0BEC5;"># </span><span style="color: #B0BEC5;">If true clear cache.</span>
<span style="color: #37474F; font-weight: bold;">nthreads</span>=64

$<span style="color: #37474F; font-weight: bold;">delete_cache</span> &amp;&amp; <span style="color: #FFAB91;">\</span>
    <span style="color: #000000;">[</span> -d $<span style="color: #37474F; font-weight: bold;">cache_dir</span> <span style="color: #000000;">]</span> &amp;&amp; <span style="color: #FFAB91;">\</span>
    rm -r $<span style="color: #37474F; font-weight: bold;">cache_dir</span>

<span style="color: #000000;">[</span> -d $<span style="color: #37474F; font-weight: bold;">import_dir</span> <span style="color: #000000;">]</span> &amp;&amp; rm -r $<span style="color: #37474F; font-weight: bold;">import_dir</span>
mkdir -p $<span style="color: #37474F; font-weight: bold;">import_dir</span>
</pre>
</div>

<p>
Within the cache directory is a <code>processed.txt</code> file which contains a list of all files that have been read.
We can use this to filter out files that have already been read in the case the program has been stopped:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">if</span> <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> -f $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/processed.txt <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span>; <span style="color: #673AB7;">then</span>
    <span style="color: #37474F; font-weight: bold;">files</span>=$<span style="color: #000000;">(</span>cat $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/processed.txt &lt;<span style="color: #a8007f;">(</span>ls <span style="color: #FFAB91;">"$data_dir/*.xml.gz"</span><span style="color: #a8007f;">)</span> <span style="color: #FFAB91;">\</span>
        | sort | uniq -u<span style="color: #000000;">)</span>
<span style="color: #673AB7;">else</span>
    <span style="color: #37474F; font-weight: bold;">files</span>=<span style="color: #FFAB91;">"$data_dir/*.xml.gz"</span>
<span style="color: #673AB7;">fi</span>
</pre>
</div>

<p>
Then read the files.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #B0BEC5;"># </span><span style="color: #B0BEC5;">Assuming the executables are in this directory and not installed globally.</span>
<span style="color: #37474F; font-weight: bold;">PATH</span>=<span style="color: #FFAB91;">"$bin_dir:$PATH"</span> <span style="color: #37474F; font-weight: bold;">OMP_NUM_THREADS</span>=<span style="color: #FFAB91;">"$nthreads"</span> read_xml <span style="color: #FFAB91;">\</span>
    --structure-file=$<span style="color: #37474F; font-weight: bold;">structure_file</span> <span style="color: #FFAB91;">\</span>
    --cache-dir=$<span style="color: #37474F; font-weight: bold;">cache_dir</span> <span style="color: #FFAB91;">\</span>
    $<span style="color: #37474F; font-weight: bold;">files</span>
</pre>
</div>

<p>
If <code>read_xml</code> was run across multiple files, the files are read in parallel and each thread will print to it's own set of files, distinguished by their thread number.
The script <code>cat_resuts.sh</code> can be used to combine the results across threads so there is one file for each node type.
</p>

<div class="org-src-container">
<pre class="src src-bash">$<span style="color: #37474F; font-weight: bold;">top_dir</span>/cat_results.sh $<span style="color: #37474F; font-weight: bold;">cache_dir</span>
</pre>
</div>

<p>
Now using the <code>yaml_get_key_components</code> executable, we can read the contents of the structure file into shell and use those to generate ids, create a list of all nodes for each node type, join the nodes with <code>key</code> to create edge lists, and generate <code>neo4j</code> style headers.
</p>

<p>
First, the <code>yaml_get_key_components</code> can be written into a wrapper function so we don't have to keep passing the same arguments.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">components</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
    <span style="color: #673AB7;">local</span> <span style="color: #37474F; font-weight: bold;">name</span>=$<span style="color: #37474F; font-weight: bold;">1</span>
    <span style="color: #37474F; font-weight: bold;">PATH</span>=<span style="color: #FFAB91;">"$bin_dir:$PATH"</span> yaml_get_key_component <span style="color: #FFAB91;">\</span>
        --structure-file=$<span style="color: #37474F; font-weight: bold;">structure_file</span> $<span style="color: #37474F; font-weight: bold;">name</span>
<span style="color: #000000;">}</span>
</pre>
</div>
</div>

<div id="outline-container-org4b301de" class="outline-3">
<h3 id="org4b301de"><span class="section-number-3">2.1.</span> Generating node files</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To generate nodes we will remove remove the <code>PMID</code> column, sort, keep the unique rows, then print with line numbers (which will be used as IDs).
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">tabsep</span>=<span style="color: #FFAB91;">"=+=t=+="</span> <span style="color: #B0BEC5;"># </span><span style="color: #B0BEC5;">Key to keep non-id columns together</span>
<span style="color: #37474F; font-weight: bold;">spcsep</span>=<span style="color: #FFAB91;">"=+s+="</span>

<span style="color: #37474F; font-weight: bold;">gen_node</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
    <span style="color: #673AB7;">local</span> <span style="color: #37474F; font-weight: bold;">key</span>=$<span style="color: #37474F; font-weight: bold;">1</span>

    <span style="color: #37474F; font-weight: bold;">key_file</span>=$<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #37474F; font-weight: bold;">key</span>.tsv
    paste &lt;<span style="color: #a8007f;">(</span>cut -f1 $<span style="color: #37474F; font-weight: bold;">key_file</span><span style="color: #a8007f;">)</span> <span style="color: #FFAB91;">\</span>
        &lt;<span style="color: #a8007f;">(</span>cut -f1 --complement $<span style="color: #37474F; font-weight: bold;">key_file</span> | <span style="color: #FFAB91;">\</span>
        sed -e <span style="color: #FFAB91;">"s/\\t/$tabsep/g"</span> -e  <span style="color: #FFAB91;">"s/\\s/$spcsep/g"</span><span style="color: #a8007f;">)</span> | <span style="color: #FFAB91;">\</span>
        sort -k 2 &gt; <span style="color: #FFAB91;">\</span>
        tmp_$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #a8007f;">}</span> &amp;&amp; mv tmp_$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #a8007f;">}</span> $<span style="color: #37474F; font-weight: bold;">key_file</span>

    cut -f1 --complement $<span style="color: #37474F; font-weight: bold;">key_file</span> | sort -u | <span style="color: #FFAB91;">\</span>
        cat -n | sed <span style="color: #FFAB91;">'s/^\s*//'</span> &gt; $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #a8007f;">}</span>_nodes.tsv
<span style="color: #000000;">}</span>

<span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read key value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">key</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    gen_node $<span style="color: #37474F; font-weight: bold;">key</span> &amp;
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
<span style="color: #673AB7;">wait</span>
</pre>
</div>

<p>
<b>Note</b>: the <code>reference</code> file is really an edge file (publication&#x2013;publication edges) so it doesn't make sense to make a node file for it.
Additionally, since both of it's columns are PMIDs they should not be renumbered, instead IDs generated for the <code>publication</code> nodes will be used to renumber both columns of <code>reference</code>.
</p>

<p>
The <code>key_features</code> files will be added to the <code>key</code> file as another node file but that will be done later to prevent them from getting in the way of joins while creating the edge files.
But before making the edge files, we'll generate IDs for the key file too.
<code>PMID</code> would work as a unique identifier, but by creating a IDs we can ensure the values are a range from 1--<code>n_publications</code> which will make it possible to use as indices for other applications (See <a href="#example-overlap">3</a>).
</p>

<p>
<b>Note</b>: The publications may reference files outside of the database leading to values in the second column of the reference file to not be included in the publication node file so we have to add them to the cache publication file.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">key_value</span>=$<span style="color: #000000;">(</span>components key<span style="color: #000000;">)</span>
<span style="color: #37474F; font-weight: bold;">key</span>=$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key_value</span>%%:*<span style="color: #000000;">}</span>
cat &lt;<span style="color: #000000;">(</span>cut -f1 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #37474F; font-weight: bold;">key</span>.tsv<span style="color: #000000;">)</span> &lt;<span style="color: #000000;">(</span>cut -f2 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/Reference.tsv<span style="color: #000000;">)</span> <span style="color: #FFAB91;">\</span>
    | sort -u | cat -n | sed <span style="color: #FFAB91;">'s/^\s*//'</span> &gt; $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv
</pre>
</div>

<p>
The resulting file has the new IDs in column one and the PMIDs in column two.
</p>
</div>
</div>
<div id="outline-container-orgb1db7a1" class="outline-3">
<h3 id="orgb1db7a1"><span class="section-number-3">2.2.</span> Generating edge files</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Now we need to join the cache files with their node files to add the node ID columns to the cache files.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">node</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    join -j 2 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>.tsv $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_nodes.tsv | <span style="color: #FFAB91;">\</span>
        sort -k 2b,2 &gt; $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_tmp.tsv &amp;
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
<span style="color: #673AB7;">wait</span>
</pre>
</div>

<p>
Then to create the edge files, join the publication node file with the cached files on PMID and remove the features so only the IDs are left.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">node</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    join -j 2 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_tmp.tsv $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv | <span style="color: #FFAB91;">\</span>
        awk <span style="color: #FFAB91;">'{ print $4,"\t",$3 }'</span>&gt; <span style="color: #FFAB91;">\</span>
        $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_edges.tsv &amp;
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
<span style="color: #673AB7;">wait</span>
</pre>
</div>

<p>
Now replace the PMIDs in the reference file to the new publication IDs by both columns with the publication nodes file.
</p>

<div class="org-src-container">
<pre class="src src-bash">paste &lt;<span style="color: #000000;">(</span>join -1 2 -2 1 $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #a8007f;">}</span>_nodes.tsv &lt;<span style="color: #a8007f;">(</span>sort -k 1 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/Reference.tsv<span style="color: #a8007f;">)</span> | cut -d<span style="color: #FFAB91;">" "</span> -f2<span style="color: #000000;">)</span> <span style="color: #FFAB91;">\</span>
    &lt;<span style="color: #000000;">(</span>join -j 2 $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #a8007f;">}</span>_nodes.tsv &lt;<span style="color: #a8007f;">(</span>sort -k 2 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/Reference.tsv<span style="color: #a8007f;">)</span> | cut -d<span style="color: #FFAB91;">" "</span> -f2<span style="color: #000000;">)</span> &gt; <span style="color: #FFAB91;">\</span>
    $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_edges.tsv
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd78b6b" class="outline-3">
<h3 id="orgdd78b6b"><span class="section-number-3">2.3.</span> Joining key's features to key</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<pre class="src src-bash">awk <span style="color: #FFAB91;">'{ print $2,$1 }'</span> &lt; $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv &gt; tmp &amp;&amp; <span style="color: #FFAB91;">\</span>
    mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv
<span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read key_feature value; <span style="color: #673AB7;">do</span>
    join -j 1 $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv <span style="color: #FFAB91;">\</span>
        &lt;<span style="color: #000000;">(</span>sort -k 1b,1 $<span style="color: #37474F; font-weight: bold;">cache_dir</span>/$<span style="color: #a8007f;">{</span><span style="color: #37474F; font-weight: bold;">key_feature</span><span style="color: #a8007f;">}</span>.tsv<span style="color: #000000;">)</span> &gt; tmp <span style="color: #FFAB91;">\</span>
        &amp;&amp; mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components key_features)"</span>
sed <span style="color: #FFAB91;">'s/\s/\t/g'</span> &lt; $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv | cut -f 2- &gt; tmp &amp;&amp; <span style="color: #FFAB91;">\</span>
    mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv
</pre>
</div>
</div>
</div>

<div id="outline-container-orga19c765" class="outline-3">
<h3 id="orga19c765"><span class="section-number-3">2.4.</span> Cleaning up (replacing temporary separators)</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    sed -e <span style="color: #FFAB91;">'s/ /\t/g'</span> -e <span style="color: #FFAB91;">"s/$tabsep/\t/g"</span> -e <span style="color: #FFAB91;">"s/$spcsep/ /g"</span> &lt; $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_nodes.tsv &gt; tmp_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span> &amp;&amp; <span style="color: #FFAB91;">\</span>
        mv tmp_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span> $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_nodes.tsv &amp;
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
<span style="color: #673AB7;">wait</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac9c7f8" class="outline-3">
<h3 id="orgac9c7f8"><span class="section-number-3">2.5.</span> Adding headers</h3>
<div class="outline-text-3" id="text-2-5">
<p>
For the key nodes:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">key_value</span>=$<span style="color: #000000;">(</span>components key<span style="color: #000000;">)</span>
<span style="color: #37474F; font-weight: bold;">key</span>=$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key_value</span>%%:*<span style="color: #000000;">}</span>
<span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">"${key}Id:ID($key)"</span>
<span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">"${header}\t${node}"</span>
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components key_features)"</span>

cat &lt;<span style="color: #000000;">(</span><span style="color: #673AB7;">echo</span> -e $<span style="color: #37474F; font-weight: bold;">header</span><span style="color: #000000;">)</span> $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv &gt; <span style="color: #FFAB91;">\</span>
    tmp &amp;&amp; mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_nodes.tsv
</pre>
</div>

<p>
For other nodes:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">node</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    <span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">"${node}Id:ID(${node})"</span>
    <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">','</span>; <span style="color: #673AB7;">for</span> v<span style="color: #673AB7;"> in</span> $<span style="color: #37474F; font-weight: bold;">value</span>; <span style="color: #673AB7;">do</span>
        <span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">"${header}\t${v}"</span>
    <span style="color: #673AB7;">done</span>

    cat &lt;<span style="color: #000000;">(</span><span style="color: #673AB7;">echo</span> -e $<span style="color: #37474F; font-weight: bold;">header</span><span style="color: #000000;">)</span> $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_nodes.tsv &gt; <span style="color: #FFAB91;">\</span>
        tmp &amp;&amp; mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_nodes.tsv
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
</pre>
</div>

<p>
For edges (excluding references):
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">node</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    <span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">":START_ID(${key})"</span>
    <span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">"${header}\t:END_ID(${node})"</span>

    cat &lt;<span style="color: #000000;">(</span><span style="color: #673AB7;">echo</span> -e $<span style="color: #37474F; font-weight: bold;">header</span><span style="color: #000000;">)</span> $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_edges.tsv &gt; <span style="color: #FFAB91;">\</span>
        tmp &amp;&amp; mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">node</span><span style="color: #000000;">}</span>_edges.tsv
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>
</pre>
</div>

<p>
For the special case of references, both IDs should be publications:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">header</span>=<span style="color: #FFAB91;">":START_ID($key)\t:END_ID($key)"</span>
cat &lt;<span style="color: #000000;">(</span><span style="color: #673AB7;">echo</span> -e $<span style="color: #37474F; font-weight: bold;">header</span><span style="color: #000000;">)</span> $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_edges.tsv &gt; <span style="color: #FFAB91;">\</span>
    tmp &amp;&amp; mv tmp $<span style="color: #37474F; font-weight: bold;">import_dir</span>/$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_$<span style="color: #000000;">{</span><span style="color: #37474F; font-weight: bold;">key</span><span style="color: #000000;">}</span>_edges.tsv
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-example-overlap" class="outline-2">
<h2 id="example-overlap"><span class="section-number-2">3.</span> <span class="todo TODO">TODO</span> Example: calculating overlap</h2>
<div class="outline-text-2" id="text-example-overlap">
</div>
</div>

<div id="outline-container-orgfcedd02" class="outline-2">
<h2 id="orgfcedd02"><span class="section-number-2">4.</span> Example: importing with neo4j</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #37474F; font-weight: bold;">import_file</span>=example/importpubmed.sh
cat &gt; $<span style="color: #37474F; font-weight: bold;">import_file</span> &lt;&lt;_EOF_
<span style="color: #2544bb;">#!/usr/bin/env bash</span>

<span style="color: #2544bb;">database_dir=\$XDG_DATA_HOME/neo4j/data</span>
<span style="color: #2544bb;">import_dir=$import_dir</span>
<span style="color: #2544bb;">name=neo4j</span>

<span style="color: #2544bb;">[ -d \$database_dir ] &amp;&amp; rm -r \$database_dir</span>

<span style="color: #2544bb;">neo4j-admin import \\</span>
<span style="color: #2544bb;">    --database=\$name \\</span>
<span style="color: #2544bb;">    --delimiter="\\t" \\</span>
<span style="color: #2544bb;">    --quote="\\"" \\</span>
<span style="color: #2544bb;">    --skip-bad-relationships=true \\</span>
<span style="color: #2544bb;">    --trim-strings=true \\</span>
<span style="color: #2544bb;">    --id-type=STRING \\</span>
<span style="color: #2544bb;">_EOF_</span>

<span style="color: #673AB7;">while</span> <span style="color: #37474F; font-weight: bold;">IFS</span>=<span style="color: #FFAB91;">': '</span> read node value; <span style="color: #673AB7;">do</span>
    <span style="color: #000000;">[</span><span style="color: #a8007f;">[</span> $<span style="color: #37474F; font-weight: bold;">node</span> == <span style="color: #FFAB91;">"Reference"</span> <span style="color: #a8007f;">]</span><span style="color: #000000;">]</span> &amp;&amp; <span style="color: #673AB7;">continue</span>
    <span style="color: #673AB7;">echo</span> <span style="color: #FFAB91;">"    --nodes=${node}=\$import_dir/${node}_nodes.tsv \\"</span> &gt;&gt; $<span style="color: #37474F; font-weight: bold;">import_file</span>
    <span style="color: #673AB7;">echo</span> <span style="color: #FFAB91;">"    --relationships=${key}-${node}=\$import_dir/${key}_${node}_edges.tsv \\"</span> &gt;&gt; $<span style="color: #37474F; font-weight: bold;">import_file</span>
<span style="color: #673AB7;">done</span> &lt;&lt;&lt; <span style="color: #FFAB91;">"$(components nodes)"</span>

<span style="color: #673AB7;">echo</span> <span style="color: #FFAB91;">"    --nodes=${key}=\$import_dir/${key}_nodes.tsv \\"</span> &gt;&gt; $<span style="color: #37474F; font-weight: bold;">import_file</span>
<span style="color: #673AB7;">echo</span> <span style="color: #FFAB91;">"    --relationships=${key}-${key}=\$import_dir/${key}_${key}_edges.tsv"</span> &gt;&gt; $<span style="color: #37474F; font-weight: bold;">import_file</span>

chmod +x $<span style="color: #37474F; font-weight: bold;">import_file</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: David R. Connell</p>
<p class="date">Created: 2022-04-21 Thu 23:08</p>
</div>
</body>
</html>
